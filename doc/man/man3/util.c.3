.TH "C:/Users/aurib/source/Repos/TFO-SYS_TP-Projects/TP/AUSH/src/util.c" 3 "Mon Apr 5 2021" "AUSH" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/Users/aurib/source/Repos/TFO-SYS_TP-Projects/TP/AUSH/src/util.c
.SH SYNOPSIS
.br
.PP
\fC#include <string\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <dirent\&.h>\fP
.br
\fC#include <pwd\&.h>\fP
.br
\fC#include <readline/readline\&.h>\fP
.br
\fC#include <readline/history\&.h>\fP
.br
\fC#include 'util\&.h'\fP
.br
\fC#include 'types\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBcreateTokens\fP (char *, char **, int len)"
.br
.ti -1c
.RI "\fBpipe_t\fP \fBcreateTokensPipe\fP (char *input, char *lhand, char *rhand, char **lhandParsed, char **rhandParsed)"
.br
.RI "Creates Tokens for a pipe\&. "
.ti -1c
.RI "int \fBisPipe\fP (char *string)"
.br
.RI "Is input a pipe\&. "
.ti -1c
.RI "int \fBstartswith\fP (char *str, char *seq)"
.br
.RI "Does str start with seq\&. "
.ti -1c
.RI "int \fBendswith\fP (char *, char *)"
.br
.ti -1c
.RI "void \fBremoveWhitespaces\fP (char *str)"
.br
.RI "Removes spaces around str\&. "
.ti -1c
.RI "int \fBcreateTokens\fP (char *input, char *out[], int len)"
.br
.RI "Create Tokens\&. "
.ti -1c
.RI "int \fBcountChar\fP (char *input, char chr)"
.br
.RI "Counts chr in input\&. "
.ti -1c
.RI "\fBpipe_t\fP \fBparseInput\fP (char *cmd, char *out[], int argCount, \fBAUSH_CMD_FLAG\fP *flag)"
.br
.RI "Parses the input\&. "
.ti -1c
.RI "int \fBcontains\fP (char *input, char chr)"
.br
.RI "Is chr in input\&. "
.ti -1c
.RI "void \fBsetFlag\fP (char *cmd, \fBAUSH_CMD_FLAG\fP *flag)"
.br
.RI "Set the Flag\&. "
.ti -1c
.RI "void \fBexe\fP (char *cmd, char *args[], int *lastRet)"
.br
.RI "Executes a command\&. "
.ti -1c
.RI "int \fBgetUserInput\fP (char *out)"
.br
.RI "Gets the User Input\&. "
.ti -1c
.RI "char * \fBgetPrompt\fP ()"
.br
.RI "Gets the Prompt\&. "
.ti -1c
.RI "int \fBendwith\fP (char *str, char *seq)"
.br
.RI "Does str end with seq\&. "
.in -1c
.SH "Function Documentation"
.PP 
.SS "int contains (char * input, char chr)"

.PP
Is chr in input\&. 
.PP
\fBParameters\fP
.RS 4
\fIinput\fP The string to check 
.br
\fIchr\fP The char to check for 
.RE
.PP
\fBReturns\fP
.RS 4
int 1 if the string contains chr else 0 
.RE
.PP

.PP
Definition at line 238 of file util\&.c\&.
.SS "int countChar (char * input, char chr)"

.PP
Counts chr in input\&. Counts the occurences of the char chr in the string input\&. The search is case sensitive
.PP
\fBParameters\fP
.RS 4
\fIinput\fP The input string 
.br
\fIchr\fP The char to search 
.RE
.PP
\fBReturns\fP
.RS 4
int The amount of times chr occures in input 
.RE
.PP

.PP
Definition at line 117 of file util\&.c\&.
.SS "int createTokens (char *, char **, int len)"

.SS "int createTokens (char * input, char * out[], int len)"

.PP
Create Tokens\&. Takes an input string and parses tokens by separating the input strings at each whitespace character
.PP
\fBParameters\fP
.RS 4
\fIinput\fP The input string to create the tokens from 
.br
\fIout\fP The array to store the parsed arguments 
.br
\fIlen\fP The amount of arguments in the input string 
.RE
.PP
\fBReturns\fP
.RS 4
int The amount of tokens created 
.RE
.PP

.PP
Definition at line 35 of file util\&.c\&.
.SS "\fBpipe_t\fP createTokensPipe (char * input, char * lhand, char * rhand, char ** lhandParsed, char ** rhandParsed)"

.PP
Creates Tokens for a pipe\&. Takes in an input and creates a pipe struct and assignes both left and righthand strings\&. The single pipe instructions are not parsed
.PP
\fBParameters\fP
.RS 4
\fIinput\fP The input string 
.br
\fIlhand\fP The lefthand init string for the pipe struct 
.br
\fIrhand\fP The righthand init string for the pipe struct 
.br
\fIlhandParsed\fP The lefthand init string array for the pipe struct 
.br
\fIrhandParsed\fP The righthand init string array for the pipe struct 
.RE
.PP
\fBReturns\fP
.RS 4
pipe_t Returns an initialised pipe struct with the parsed string arrays 
.RE
.PP

.PP
Definition at line 66 of file util\&.c\&.
.SS "int endswith (char *, char *)"

.SS "int endwith (char * str, char * seq)"

.PP
Does str end with seq\&. Checks wether the string str ends exactly with the string seq
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string to check 
.br
\fIseq\fP The ending char sequence to compare to 
.RE
.PP
\fBReturns\fP
.RS 4
int 1 if str ends with seq else 0 
.RE
.PP

.PP
Definition at line 388 of file util\&.c\&.
.SS "void exe (char * cmd, char * args[], int * lastRet)"

.PP
Executes a command\&. Executes the command with the passed arguments and sets the return value\&. The args array has to be null terminated
.PP
\fBParameters\fP
.RS 4
\fIcmd\fP The command to execute 
.br
\fIargs\fP The argument list\&. The first is the same as cmd and the last has to be NULL 
.br
\fIlastRet\fP The pointer to the integer holding the last exit code 
.RE
.PP

.PP
Definition at line 281 of file util\&.c\&.
.SS "char* getPrompt ()"

.PP
Gets the Prompt\&. Creates the shell prompt and returns the pointer to it\&. The string is allocated with malloc() so you want to free() it after
.PP
\fBReturns\fP
.RS 4
char* The shell prompt 
.RE
.PP

.PP
Definition at line 333 of file util\&.c\&.
.SS "int getUserInput (char * out)"

.PP
Gets the User Input\&. Promps for the input using readline() from GNU libreadline and copies the input into out
.PP
\fBParameters\fP
.RS 4
\fIout\fP The pointer to copy the input to 
.RE
.PP
\fBReturns\fP
.RS 4
int 1 if the input was taken correctly else 0 
.RE
.PP

.PP
Definition at line 305 of file util\&.c\&.
.SS "int isPipe (char * string)"

.PP
Is input a pipe\&. Checks wether the given string is a pipe by checking if the | char is contained
.PP
\fBParameters\fP
.RS 4
\fIstring\fP The string to check 
.RE
.PP
\fBReturns\fP
.RS 4
int 1 if the string is a pipe else 0 
.RE
.PP

.PP
Definition at line 103 of file util\&.c\&.
.SS "\fBpipe_t\fP parseInput (char * cmd, char * out[], int argCount, \fBAUSH_CMD_FLAG\fP * flag)"

.PP
Parses the input\&. Takes an input string and parses the string returning a full pipe struct if the input was a pipe else it writes the args into the out array\&. The pipe functionality is not yet implemented and will lead to a crash
.PP
\fBParameters\fP
.RS 4
\fIcmd\fP The input to parse 
.br
\fIout\fP The array of args to write to if the input isn't a pipe 
.br
\fIargCount\fP The amount of arguments in the input 
.br
\fIflag\fP The pointer to the flag to set according to the parsing 
.RE
.PP
\fBReturns\fP
.RS 4
pipe_t Returns a filled or empty pipe struct 
.RE
.PP

.PP
Definition at line 145 of file util\&.c\&.
.SS "void removeWhitespaces (char * str)"

.PP
Removes spaces around str\&. Removes leading and trailing whitespace characters from the string s
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string to remove the spaces from 
.RE
.PP

.PP
Definition at line 416 of file util\&.c\&.
.SS "void setFlag (char * cmd, \fBAUSH_CMD_FLAG\fP * flag)"

.PP
Set the Flag\&. Sets the flag according to the input\&. Only sets flags for shell specific commands
.PP
\fBParameters\fP
.RS 4
\fIcmd\fP The command to check 
.br
\fIflag\fP The pointer to the flag to set 
.RE
.PP

.PP
Definition at line 252 of file util\&.c\&.
.SS "int startswith (char * str, char * seq)"

.PP
Does str start with seq\&. Checks wether the string str starts exactly with the string seq
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string to check 
.br
\fIseq\fP The starting char sequence to compare to 
.RE
.PP
\fBReturns\fP
.RS 4
int 1 if str starts with seq else 0 
.RE
.PP

.PP
Definition at line 358 of file util\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for AUSH from the source code\&.
